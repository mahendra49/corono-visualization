{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/index.js","webpack:///./src/js/utils.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,KAAK;;AAEL,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,aAAa,EAAE;;AAEzC;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,8CAAK;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,8CAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA,cAAc,8CAAK;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC,cAAc,8CAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B,2BAA2B,8CAAK;AAChC;AACA,qBAAqB,8CAAK;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA,mDAAmD,WAAW;AAC9D,sDAAsD,eAAe;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzTA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEe,gEAAC,6CAA6C,EAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/index.js\");\n","import utils from \"./utils\";\n//const colors = [\"#e25a53\", \"#fdb35d\", \"#fbf5e8\", \"#a4d9d6\"];\n//ALL DATA\n\nconst NUMBER_OF_PEOPLE = 1000;\nconst INFECTED_PEOPLE = 10;\nconst INFECTED_COLOR = \"#e25a53\";\nconst NORMAL_COLOR = \"#5FAD41\";\nconst QUARATINR_COLOR = \"#996515\";\nconst DEAD_COLOR = \"#000000\";\nconst LOCKDOWN_COUNT = 700;\nconst CURRENT_ACTION = `LOCKDOWN(${LOCKDOWN_COUNT /\n  10}%) - MEDICATION AVAILABLE - ASSUME DEATHS`;\n\nconst MAX_DISTANCE = -5; //social distance 3\nconst CANVAS_HEIGHT = 570;\nconst CANVAS_WIDTH = 500;\n\n//hospotal data\nconst is_hospital = true;\nconst hos_height = 100;\nconst hos_width = 100;\nconst RANDOMLY_INFECT_COUNT = 5;\nconst REDUCE_HEALTH_BY_FACTOR_MAX_LIMIT = 10;\nconst INCR_HEALTH_BY_FACTOR_MAX_LIMIT = 7;\nconst DEATH_AT_LIMIT_BELOW = 50; //health below 20 dies\nconst SAFE_ABOVE_LIMIT = 400; //max is 600 ie..ttl in circles\n//const hos_color = \"#de7119\";\n//animation events\nlet animation_id;\nlet isPaused = true;\n\nconst canvas = document.querySelector(\"#my-canvas\");\nlet c = canvas.getContext(\"2d\");\ncanvas.width = CANVAS_WIDTH;\ncanvas.height = CANVAS_HEIGHT;\n\nlet line_chart;\nconst _line_chart_canvas = document.querySelector(\"#line-chart\");\nlet line_chart_c = _line_chart_canvas.getContext(\"2d\");\n\nconst mouse = {\n  x: undefined,\n  y: undefined\n};\n\nlet circles = [];\n//let line_chart_data = [{ x: 1, y: 1 }]; // x : days, y:infected\n\nlet days = 0;\nlet total_frames = 0;\nlet frame_to_days = 60; //every 60 days as a day\n\n// all classes\nclass Circle {\n  constructor(x, y, r, color, dx, dy) {\n    this.x = x;\n    this.y = y;\n    this.r = r || 15;\n    this.color = color;\n    this.dx = dx || velocity.dx;\n    this.dy = dy || velocity.dy;\n    this.ttl = frame_to_days * 10; //time to recover lets say 10 days so frame_to_days*10\n  }\n\n  draw() {\n    c.save();\n    c.beginPath();\n    c.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);\n    c.fillStyle = this.color;\n    c.fill();\n    c.closePath();\n    c.restore();\n  }\n\n  update() {\n    if (this.color == INFECTED_COLOR) {\n      this.ttl =\n        this.ttl -\n        (utils.getRandomInt(2, REDUCE_HEALTH_BY_FACTOR_MAX_LIMIT) * 100) /\n          this.ttl;\n      if (this.ttl <= DEATH_AT_LIMIT_BELOW) this.color = DEAD_COLOR;\n    }\n\n    if (this.color == INFECTED_COLOR) {\n      this.ttl =\n        this.ttl +\n        (utils.getRandomInt(1, INCR_HEALTH_BY_FACTOR_MAX_LIMIT) * 100) /\n          this.ttl;\n    }\n    if (this.color == INFECTED_COLOR && this.ttl >= SAFE_ABOVE_LIMIT)\n      this.color = NORMAL_COLOR;\n    this.checkForWindow();\n    this.x += this.dx;\n    this.y += this.dy;\n    this.draw();\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  checkForWindow() {\n    if (\n      (is_hospital && checkIfNearHospital(this)) ||\n      this.x + this.r > canvas.width ||\n      this.x - this.r < 0\n    )\n      this.dx = -this.dx;\n    if (\n      (is_hospital && checkIfNearHospital(this)) ||\n      (this.x >= canvas.width - hos_width &&\n        this.y + this.r > canvas.height - hos_height) ||\n      this.y + this.r > canvas.height ||\n      this.y - this.r < 0\n    )\n      this.dy = -this.dy;\n  }\n}\n\n//simulate lockdown\nfunction lockdown(count) {\n  for (let i = 0; i < count; i++) {\n    circles[i].dx = 0;\n    circles[i].dy = 0;\n  }\n}\n\nfunction collide(circle) {\n  for (let i of circles) {\n    if (i == circle) continue;\n    const distance = utils.distance(i, circle) - circle.r - i.r;\n    //if came into contact mark color as red and reduce some health\n    if (distance < MAX_DISTANCE && circle.color === INFECTED_COLOR) {\n      i.color = INFECTED_COLOR;\n      i.ttl = utils.getRandomInt(350, 500);\n    }\n  }\n}\n\n/* \n  100 GREEN people and 1 RED PEOPLE\n*/\nfunction init() {\n  circles = [];\n  for (let i = 0; i < NUMBER_OF_PEOPLE; i++) {\n    const r = utils.getRandomArbitrary(2, 4);\n    const x = Math.random() * canvas.width;\n    const y = Math.random() * canvas.height;\n    const color = NORMAL_COLOR;\n    const dx = (Math.random() - 0.5) * 5;\n    const dy = (Math.random() - 0.5) * 5;\n    const circle = new Circle(x, y, r, color, dx, dy);\n    if (is_hospital && checkIfNearHospital(circle)) {\n      i--;\n      continue;\n    }\n    circles.push(circle);\n  }\n  fill_infected(INFECTED_PEOPLE);\n  lockdown(LOCKDOWN_COUNT);\n}\n\nfunction draw_line_chart() {\n  Chart.defaults.scale.gridLines.display = false;\n  line_chart = new Chart(line_chart_c, {\n    type: \"line\",\n    data: {\n      labels: [],\n      datasets: [\n        {\n          label: `INFECTED - ${CURRENT_ACTION}`,\n          data: [],\n          borderColor: INFECTED_COLOR,\n\n          borderWidth: 2\n        },\n        {\n          label: `DEATHS`,\n          data: [],\n          borderColor: DEAD_COLOR,\n\n          borderWidth: 3\n        }\n      ]\n    },\n    scales: {\n      xAxes: [\n        {\n          // aqui controlas la cantidad de elementos en el eje horizontal con autoSkip\n          ticks: {\n            autoSkip: true,\n            maxTicksLimit: 20\n          },\n          gridLines: {\n            color: \"rgba(0, 0, 0, 0)\"\n          }\n        }\n      ],\n      yAxes: [\n        {\n          // aqui controlas la cantidad de elementos en el eje horizontal con autoSkip\n          ticks: {\n            autoSkip: true,\n            maxRotation: 0,\n            minRotation: 0\n          },\n          gridLines: {\n            color: \"rgba(0, 0, 0, 0)\"\n          }\n        }\n      ]\n    }\n  });\n}\n\nfunction fill_infected(count) {\n  for (let i = 0; i < count; i++) {\n    circles[i].color = INFECTED_COLOR;\n    //give time to live randomly between 350 and 400\n    circles[i].ttl = utils.getRandomInt(350, 400);\n  }\n}\n\n//all hospital related functions\nfunction hospital(params) {\n  c.rect(\n    CANVAS_WIDTH - hos_width,\n    CANVAS_HEIGHT - hos_height,\n    hos_width,\n    hos_height\n  );\n  c.strokeStyle = \"black\";\n  c.stroke();\n}\n\nfunction checkIfNearHospital(tmp_circle) {\n  if (\n    tmp_circle.y >= canvas.height - hos_height &&\n    tmp_circle.x + tmp_circle.r > canvas.width - hos_width\n  )\n    return true;\n\n  if (\n    tmp_circle.x >= canvas.width - hos_width &&\n    tmp_circle.y + tmp_circle.r > canvas.height - hos_height\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n//infect randoly no direct contact\nfunction randomlyInfect(count) {\n  for (let i = 0; i < count; i++) {\n    const randome_number = utils.getRandomInt(0, circles.length - 1);\n    circles[i].color = INFECTED_COLOR;\n    circles[i].ttl = utils.getRandomInt(350, 450);\n  }\n}\n\nfunction animate() {\n  c.clearRect(0, 0, canvas.width, canvas.height);\n  if (is_hospital) hospital();\n  let total_infected = 0;\n  total_frames++;\n  circles.forEach((circle, index) => {\n    if (circle.color === INFECTED_COLOR) total_infected++;\n    if (circle.color === DEAD_COLOR) circles.splice(index, 1);\n    collide(circle);\n  });\n  circles.forEach(circle => {\n    circle.update();\n  });\n  randomlyInfect(RANDOMLY_INFECT_COUNT);\n  //every frame_to_days we count as a day\n  if (total_frames % frame_to_days === 0) {\n    days++;\n    line_chart.data.datasets[0].data.push(total_infected);\n    line_chart.data.labels.push(`day ${days}`);\n    const dead_count = NUMBER_OF_PEOPLE - circles.length;\n    line_chart.data.datasets[1].data.push(dead_count);\n    line_chart.data.datasets[1].label = `DEATH - ${dead_count}`;\n    line_chart.data.datasets[0].label = `INFECTED - ${total_infected}`;\n    line_chart.update();\n  }\n  animation_id = requestAnimationFrame(animate);\n}\n\n//all controls\nfunction allEvents(params) {\n  document\n    .querySelector(\"#start-button\")\n    .addEventListener(\"click\", function(params) {\n      if (isPaused) {\n        animate();\n        isPaused = !isPaused;\n      }\n    });\n\n  document\n    .querySelector(\"#stop-button\")\n    .addEventListener(\"click\", function(params) {\n      if (!isPaused) {\n        cancelAnimationFrame(animation_id);\n        isPaused = !isPaused;\n      }\n    });\n}\n\ninit();\ndraw_line_chart();\nallEvents();\n","export function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function distance(object1, object2) {\n  const xd = object1.x - object2.x;\n  const yd = object1.y - object2.y;\n  const dis = Math.sqrt(xd * xd + yd * yd);\n  return dis;\n}\n\nexport default { getRandomArbitrary, getRandomInt, distance };\n"],"sourceRoot":""}